\documentclass[11pt]{article} 
\usepackage[pdftex]{graphicx}
 
\title{CS350 QuickHull Project Report}
\author{Gregory Haynes and Eric O'Connell}
\date{December 1 2011}

\begin{document}
\maketitle

\section{Introduction}

In mathematics the convex hull of a set of points X is the minimum convex set containing X\cite{Wikipedia:QH}. In this paper we describe an efficient method for computing the convex hull of a set of discrete points while offering comparisons to a brute force solution. There are many practical applications to the problem of determining convex hulls. These applications range from Image processing to static code analysis all ofwhich make the discovery of efficient algorithms to compute the convex hull a worthwhile subject.

\section{Algorithm Explanation}

The quickhull algorithm, given its name due to its similarity to the quicksort algorithm, is a fast method for determining the convex hull of a set of points. There are two phases to the quickhull algorithm. The first phase splits the set into an upper and lower portion using a chord between two points known to be on the convex hull (See Pivot Chord Selection). These two points are then added to the set of points on the hull. The next phase of the algorithm takes the chord and either the upper of lower set of points and recursively finds points on the convex hull. This phase first determines the farthest point from the chord, then adds this point to set set of convex hull points. This phase then makes two recursive calls with the two sets of points outside the triangle formed by each input chord point and the farthest point. A more detailed description is provided in the Quickhull Psuedocode.

\subsection{Quickhull Pseudocode}

\textbf{TrianglePartition(P, A, B):}
\begin{verbatim}
If P is the empty set return the empty set
Let C be the farthest point from the line containing A and B
Let L be a subset of P where each element is left of the line A..C
Let R be a subset of P where each element is left of the line C..B
Let CH <- TrianglePartition(L, A, C) + {CH}
   + TrianglePartition(R, C, B)
Return CH
\end{verbatim}
\textbf{Quickhull(P):}
\begin{verbatim}
Let C be a chord from point C.a to C.b where 
   both C.a and C.b are points on the convex hull of P
Let U be a subset of P where each element in U is above C
Let L be a subset of P where each element in L is below C
Let CH <- {C.a} + TrianglePartition(P, C.a, C.b) + 
   {C.b} + TrianglePartition(P, C.b, C.a)
Return CH
\end{verbatim}

\subsection{Pivot Chord Selection}
The pivot chord selection in quickhull plays a major role in the efficiency of the algorithm, much like pivot selection in its quicksort counterpart. For this project the chord was selected by finding the maximum and minimum values along the X axis and then using the maximum and minumum Y values in cases of matching X values. This could be easily modified to select a chord along the Y axis. More advanced chord selection techniques are beyond the scope of this project.

\section{Implementation}
Our quickhull algorithm was implemented using JavaScript and HTML for visualization. This language was chosen due to the ease with which results could be visually displayed using minimal code. Aditionally, recent advancements in JavaScript interpreters allow for reasonably fast execution of the algorithm. Furthermore, extensive profiling software exists in many modern web browsers which allow us to easily generate run time performance data.

\subsection{Verification}
To verify the correctness of our quickhull implementation we developed a brute force convex hull algorithm and compared the outputs of these two solutions. We used psuedo-random point data as input which was fitted to several distributions: distributed evenly, along a circle edge, and along a line with psuedo-randomly determined slope. The evenly distributed data and circular distribution data passed all verification tests. When testing the line-fitted data we encountered errors when the slope approached 0 or infinity. Unpon closer inspection it was noted that the brute force algorithm was not outputting the expected two point convex hull solution. We believe this is due to floating point error which prevented us from forming a truly straight line. Based on this assumption we believe the quickhull algorithm is more succeptible to floating point error for sets of points nearly fitted to a line as there are many more floating point operations used to determine each points position relative to a chord.

\subsubsection{Brute Force Psuedocode}
\begin{verbatim}
Let CH be an empty set
For each pair of points (A, B):
   If all points in P are below the vector A..B then add A, B to CH
Return CH
\end{verbatim}

\section{Analysis}

\subsection{Complexity}
The complexity of the quickhull algorithm can be derived by constructing a recurrence relation for the worst case of TrianglePartition (see quickhull psuedocode). This worst case exists when the triangle (ABC) used in TriangleParticion does not contain any points (other than A, B, C). In this case, only one point is eliminated from the set of possible points. Finding the farthest point (C) requires O(n) time. Thus, the recurrence relation is:
\[ T(n) = T(n - 1) + T(n - 1) + O(n) \]
After expansion this recurrence releation solves to $O(n^2)$ complexity\cite{Kent:QH}.
\\
\\
With an evenly spaced distribution we can expect the triangle ABC to encompass half of the points, which gives us the following recurrence relation
\[ T(n) = T(n / 2) + T(n / 2) + O(n) \]
Using the Master Theorem we can solve this recurrence relation as being $O(n log(n))$ complexity\cite{Kent:QH}.

\subsection{Experimental Performance}
In order to determine the efficiency of the algorithm as implemented, we used the JavaScript console.profile API to measure successive runs of quickhull on increasingly-large sets of points. As a basis point of comparison, we also measured the running time of the brute-force function.

The first two graphs show performance on point sets ranging from 200 to 2,000 points on linear and circular data, respectively, for both quickhull and the bruteforce method. By means of polynomial regression, we were able to ascertain that the brute force method grows at order $O(n^2)$. We were surprised by this because the algorithm we use is essentially a triply-nested loop, which should show order $O(n^3)$.

\begin{figure}
	\caption{Quickhull vs. brute-force on pointcloud data}
	\centering
	\includegraphics[scale=0.3]{qh-v-bf-cloud.png} 
\end{figure}

\begin{figure}
	\caption{Quickhull vs. brute-force on circular data}
	\centering
	\includegraphics[scale=0.3]{qh-v-bf-circle.png} 
\end{figure}

Because the quickhull algorithm was so much faster than the bruteforce, we created a chart with quickhull alone to illustrate its behavior:

\begin{figure}
	\caption{Quickhull scaling on pointcloud data}
	\centering
	\includegraphics[scale=0.3]{qh-only.png} 
\end{figure}

Again, we were surprised because the chart shows linear, if not sub-linear, time results for the quickhull algorithm, when the algorithm itself s $O(n log n)$. In looking into the data, we did notice that each run took longer than its predecessors, especially when the number points grew to approach 1,000,000. Our belief is that some of this data skew is due to garbage collection, but we can offer no explanation for the fact that the algorithm times appear lower by an entire order of magnitude than they are.

\subsection{Other Convex Hull Algorithms}
Grahams scan is another popular convex hull algorithm which has a worst case running time of $O(nlog(n))$. This algorithm first performs a clockwise sorting of the points and then determines, in order, which points are on the convex hull.

\section{Summary}

\nocite{Princeton:QH}
\nocite{CLRS}

\bibliographystyle{plain}
\bibliography{report}

\end{document}
